--------------------------------------------- Lesson 1 ---------------------------------------------------------
- git init > initalize repo in local folder
- git add index.html > add file from working dir to staging/indexing area
- git add * > commit all the files in working directory to staging area
- git commit -m "firt commit" > commit the file from staging area to local repo
- git status > provide status in working directory which files are tracked and which are not
- git log > provide the logs for the latest commit inlcuing the commit ID
- git ls-files > check files in your local repo and it is different than 'ls' linux command
- git show 'commit ID'  > it shows the details of that commit
- git commit -a -m "third commit" > it will add the modified files [only modified if new files it will be excluded] to staging and commit them to local repo


------------------------------------------- Lesson 2 ------------------------------------------------------------
- git diff 'file name' > shows the unstaged changes in the file which is still in the working directory so after review the changes then we should commit it to the staging directory.
- git diff --staged 'file name' > show the current changes in the file which is in staging area and after review it should be committed to local repo
- git rm --cached 'file name' > remove file from local repo and when run git status it will show that the file is untracked so it needs to be added and committed to local repo again
- vim .gitignore > create a new file in the working directory and add the file name(s) in this file so git will ignore any changes comming from these file(s).
	- git add .gitignore
	- git commit -m "commit gitignore"
- git revert 'commit ID' > it will remove the changes that was part of that commit ID
- git reset --hard 'commit ID' > it will remove all the commits and changes happened after this commit ID

----------------------------------------  lesson 3 [branching] ----------------------------------------------------------
- git branch > list all the available branches and it will put "*" beside the current running/active branch  for me.
- git checkout -b 'branch name' 'parent branch' ex: git checkout -b b1 master > means it will create a new branch 'b1' from master branch and it will copy all the files and changes that was made to master branch till the momnet and reflect it in 'b1'.
- git log --oneline 'branch name' ex: git log --oneline 'b1' > it will show the histor of all the commit and changes happened in branch 'b1'.
- git checkout 'branch name' ex: git checkout master > this will switch to master branch.
- git merge 'branch name' ex: git merge b1 > it will merge the current branch with b1 meaning all the changes that were in b1 will be added to the current branch as well so both the current branch and b1 will be the same.
- in case there is aconflict while merging, try to edit the file which has the conflict and resolve it then add and commit the file so it should work.
- git history > will display all the git executed commands.
- git stash > will save all the modified changes in working directory with some thing called 'stach ID' so we can commit the changes in working directory without including the stashed changes.
- git stash list > list all the stashes available,
- git stash pop 'stash ID' > it will retrieve back the stash ID and apply it is changes back in the working directory so we can add/commmit these changes to the stagging area/local repo. very important once the stash is unstashed automatically the stash ID will be removed.
- git stash apply 'stash ID' > it will retrieve back the stash ID and apply it is changes back in the working directory so we can add/commmit these changes to the stagging area/local repo. very important once the stash is unstashed and stash ID will not be removed.
- git stash clear > just clear all the stashes without unstashing them.
- git rebase master > means it will rebase the current branch with the master branch changes. so the current branch will be updated with the latest master branch changes with copying the same changes sequence of master branch. very impoartant rebase will not add any new commit with the changes history 'not like merge option which add new commit to the log history'.


----------------------------------------  lesson 4 [remote repo] ----------------------------------------------------------

- open the git created folder
- git remote add origin "github URL" > it will add the files and changes in the project folder to the github URL.
- git push origin master > it will push all the changes in the project folder to master branch.
- git clone 'git hub repo URL' > it will clone the current git hub repo files into the local target folder. it will clone the project from scratch means all the files will be pulled to the local folder.
- git pull origin > it will pull the changes from the current branch 'that was used during clone' and update it in the local repo.
- git fetch origin > it will tell what are the changes between the remote repo branch and the current local working directory and it will not do any update to the working directory. you can say it will just tell about the changes their.

- Pull = [ Fetch + Merge ]










